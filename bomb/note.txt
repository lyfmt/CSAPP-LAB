main 函数位置 264行
read_line,将输入的东西赋值到rdi和rsi上 (先rsi,再从rsi转移到rax上,再转移到rdi上)
phase_1 : 输入的数从string_not_equal出来后要使得eax为0
string_length : 一直增加rdx直到rdx后1字节,也就是8位为0,好好好
,也就是edx>128时离开,此时eax等于edx-edi 其值为128 - al 除非原本al就是0
根据后文 401361 al不能是0 也就是edx-edi不能等于0
也就是
再根据后文,rbx等于al
找到了,原来rsi被修改了0x402400
0x402400
0100 0000 0010 0100 0000 0000
去数据层找到了这个地址所指向的元素大小
402400 426f7264 65722072 656c6174 696f6e73  Border relations
然后按照这个循环,找到字节为零的那个地址
402435
这样eax就等于34 (16进制)实则 52

所以答案是一个与00距离52的一个地址


scanf 我们可以根据使用scanf之前拓展出多少个空间来判断传参的数量


0x402470:       0x0000000000400f7c      0x0000000000400fb9
0x402480:       0x0000000000400f83      0x0000000000400f8a
0x402490:       0x0000000000400f91      0x0000000000400f98
0x4024a0:       0x0000000000400f9f      0x0000000000400fa6
由此正好是 0 -7 八种情况
我们选取400f8a这种
则8(rsp) = 3
  c(rsp) = 100


发现了输入字符最多只有4个的限制
不过得到了可以输入-号同时充当分隔符
那我可取的范围变成了99 -- -99
仅仅是假设,我输入的负数可以溢出来得到0的结果
%eax - 0xc(%rsp)
那么,

phase_4
首先,传入有且仅有两个参数,x,y
然后第一个参数要低于等于14
跳转后,将14放入edx,0放入esi,x放入edi
调用func4
要求func4的返回值为0

func4
先将edx(14),放入eax,将eax减去esi(0) 14 2
然后将eax赋给ecx 14 2
将ecx逻辑右移31位,得0或1 0 0
给eax加上ecx(0/1) 14 2
将eax算术右移1位 0111 -> 0011 0010-> 0001
计算rax+rsi给ecx 即为rax 0011 0001
比较ecx和edi(x)
 然后判断ecx是否小于等于edi(有符号判断)
 若ecx大于edi,则将rcx地址减一赋给edx,回到函数最初 0010 0000
 直到ecx<edi(x) 每一次要经历一次除2(正数),正数在循环末尾减一,负数先加一,再除2,再减一
 变化 14 1110 -> 6 0110 -> 2 0010 -> -1 
 所以第一个参数必然>=-1
然后ecx小于等于edi时跳转,将eax改为0
    然后再次判断ecx是否小于等于edi,无符号情况~xxxxxx
    若是,则返回,功成
    否则给rcx加一后的值赋值给esi
    返回函数开始
    汇编看多了害眼睛啊
    这里是比较ecx是否比edi大,然后才能跳转,也就是要既大又小,那么则相等满足
    汇编害人我说
    所以选取相等的情况即可

