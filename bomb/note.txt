main 函数位置 264行
read_line,将输入的东西赋值到rdi和rsi上 (先rsi,再从rsi转移到rax上,再转移到rdi上)
phase_1 : 输入的数从string_not_equal出来后要使得eax为0
string_length : 一直增加rdx直到rdx后1字节,也就是8位为0,好好好
,也就是edx>128时离开,此时eax等于edx-edi 其值为128 - al 除非原本al就是0
根据后文 401361 al不能是0 也就是edx-edi不能等于0
也就是
再根据后文,rbx等于al
找到了,原来rsi被修改了0x402400
0x402400
0100 0000 0010 0100 0000 0000
去数据层找到了这个地址所指向的元素大小
402400 426f7264 65722072 656c6174 696f6e73  Border relations
然后按照这个循环,找到字节为零的那个地址
402435
这样eax就等于34 (16进制)实则 52

所以答案是一个与00距离52的一个地址


scanf 我们可以根据使用scanf之前拓展出多少个空间来判断传参的数量


0x402470:       0x0000000000400f7c      0x0000000000400fb9
0x402480:       0x0000000000400f83      0x0000000000400f8a
0x402490:       0x0000000000400f91      0x0000000000400f98
0x4024a0:       0x0000000000400f9f      0x0000000000400fa6
由此正好是 0 -7 八种情况
我们选取400f8a这种
则8(rsp) = 3
  c(rsp) = 100


发现了输入字符最多只有4个的限制
不过得到了可以输入-号同时充当分隔符
那我可取的范围变成了99 -- -99
仅仅是假设,我输入的负数可以溢出来得到0的结果
%eax - 0xc(%rsp)
那么,

phase_4
首先,传入有且仅有两个参数,x,y
然后第一个参数要低于等于14
跳转后,将14放入edx,0放入esi,x放入edi
调用func4
要求func4的返回值为0

func4
先将edx(14),放入eax,将eax减去esi(0) 14 2
然后将eax赋给ecx 14 2
将ecx逻辑右移31位,得0或1 0 0
给eax加上ecx(0/1) 14 2
将eax算术右移1位 0111 -> 0011 0010-> 0001
计算rax+rsi给ecx 即为rax 0011 0001
比较ecx和edi(x)
 然后判断ecx是否小于等于edi(有符号判断)
 若ecx大于edi,则将rcx地址减一赋给edx,回到函数最初 0010 0000
 直到ecx<edi(x) 每一次要经历一次除2(正数),正数在循环末尾减一,负数先加一,再除2,再减一
 变化 14 1110 -> 6 0110 -> 2 0010 -> -1 
 所以第一个参数必然>=-1
然后ecx小于等于edi时跳转,将eax改为0
    然后再次判断ecx是否小于等于edi,无符号情况~xxxxxx
    若是,则返回,功成
    否则给rcx加一后的值赋值给esi
    返回函数开始
    汇编看多了害眼睛啊
    这里是比较ecx是否比edi大,然后才能跳转,也就是要既大又小,那么则相等满足
    汇编害人我说
    所以选取相等的情况即可


phase_5
首先腾出了空间
然后将输入值rdi挪入rbx中
学到了缓存栈保护
%fs:0x28通常是用来做stack canary的
提前提取出一块只有系统才知道的区域,然后将其赋值给rax然后将rax放入栈中
结束后将该值提取出与原始的fs:0x28对比,两者一样才说明正常
否则则说明存入的值被覆盖,发生了栈溢出
然后函数进行保护机制后继续
根据string_length函数后的判断,需要输入一个6位字符串
  然后将rax归零后,零拓展ecx
  ecx = rbx + rax rax此时是零,rbx此时是rdi  经调试,此时ecx存的是第一个字符的ascii,rbx是全部的字符

  然后将cl(rcx的后8位)放入rsp的内存中
  再将这个值赋给rdx   这一步很关键,为什么明明是将rsp的内存赋给rdx,却得到的是
    知道了,因为movzbl是执行一个字节移动然后拓展,所以这里就将输入值的最后一位赋给ecx,0x61(97)
  然后按位与edx和0xf
  得edx的后8位
  然后将0x2024b0加上rdx后的内存地址赋给edx (应该是吧)
  然后再将其后八位赋给 10 + rsp +rax
  再对rax+1
  循环这个过程直到rax等于6
然后将0放入rsp上0x16的位置
再将rsp地址加是放入rdi中
判断rdi字符串长度是否位0
否则鸡
为零
则再将0x18(%rso)赋给%rax
这里就是判断栈是否溢出,若无,则通过

"maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?"
中间一段 40108b -- 401099 
根据输入的值的第一个如a得1 按顺序查上面的句子中的值赋给edx
然后依次遍历提取出全部的值
再然后将值放入rdi中,和系统的0x40245e比较 这个为flyers
所以我们的输入要依次获得 f l y e r s
i o n e f g

0 
phase_6
part 1 先是判断输入的个数是否为6ge
part 2 401130 配合 401151 判断其中是否有相等的值,要求一个不重复数组且最大值比6小,最小值比0大
1 2 3 4 5 6 
part 3 将ecx赋予7,减去rax里的值(数组的开始) 然后将7-x后的值赋回rax
,然后移动rax指针,直到数组最后
也就是将数组的元素x,x = 7-x 
1 2 4 8 16 32
6 5 3 -1 -9 -25  
part 4 0x6032d0 <node1>:       76  rbx    1  rax     0       0       1       0 
20 28 30 38 40 48 
0 4 8 12 16 20
0 8 16 24 32 40

先看最后,
给ebp5
然后将ebx后一位的数据写入rax
将rax的内存写入eax
比较eax和rbx
要求x后一位的内存指向的内存小于x指向的内存

在看其上
将rsp后0x20位的内存给rbx,将后0x28的地址给rax,后0x50的地址给rsi
然后将rbx赋给rcx
然后将rax的内存给rdx
然后将rdx赋给rcx后8位的内存


输入存放的空间
rsp + 4*x (x<=5)

L/100
/250
/3402
/250/002/3602

rsp0x20后8位一个 地址 地址对应的内存
76 0x6032d0    --- 6
-88 0x6032d0 -----5
-100 0x6032f0-----4
-77 0x603300-----3
-35 0x603310-----2
-69 0x603320----- 1
从大到小
6 2 1 3 5 4
4 5 3 1 2 6
3 2 4 6 5 1
5 4 3 2 1 6 
2 3 4 5 6 1
    

-100 -88 -32
-69  -77 32  -88 0 -100 -32

-88 

0x6032d0 <node1>:       0x10000014c                   0x0
0x6032e0 <node2>:       0x2000000a8             1      0x603300 <node4> 0x4000002b3
0x6032f0 <node3>:       0x30000039c              2     0x6032e0 <node2>  0xa8
0x603300 <node4>:       0x4000002b3               3    0x603320 <node6>  0x6000001bb
0x603310 <node5>:       0x5000001dd                4   0x6032d0 <node1>
0x603320 <node6>:       0x6000001bb                 5  0x603310 <node5>
0x603330:       0x0     0x0

由于截断
所以最大值是
node3 > node4 > node 5 > node 6 > node 1 >node2

所以
原本不就是从大到小
所以
4 3 2 1 6 5







接下来就是找到这个排序的逻辑
使之一一对应应该就是密钥

(gdb) x/6a $rsp+0x20
0x7fffffffdde0: 0x603320 <node6>        0x603300 <node4>
0x7fffffffddf0: 0x6032f0 <node3>        0x6032e0 <node2>
0x7fffffffde00: 0x6032d0 <node1>        0x603310 <node5>


rsp 20% 值为node 5 6 4 3 2 1
rbx 是最初输入后的7-x node启动
rax对应的是除了第一个node后的地址 故为 6 4 3 2 1
然后将rbx 即为rsp 20 的地址给rcx 
然后将 node 6 (rax) 给到rcx 后的一位 这里是移动 到28
20 28 30 38 40 48

然后移动rax到node4,然后将rdx,node6给rcx
也就是第一次时
原本为
rax(2)
0x603320 node6 次

rax(1)

rcx 初 0x603310 node 5
rax(3)
0x603300 node4 再次
rax(4)
node 3 再次次
rax(5) 1
node 2 倒2
*
node 1

1 最后
2 倒2
3 再次
4 次
rax 初 node6
node5


5 6 4 3 2 1
将rax给rcx后一个
5 6 4 3 2 1
所以第一次不变
然后将rdx给rcx,即为node6给rcx,rcx此时为5
rcx则指向6
然后跳转,rax由于进一变为4 

a b c d e f 

栈
(b)
b
(a)
a
(c)
c
(d)
d
(e)
e
*
f
所以f最小

6 5 4 3 2 1

node 6 -69  0x6000001bb
node 5 16 0x5000001dd
node 4 0
