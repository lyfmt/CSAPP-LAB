## touch1 
- 很简单,将touch1地址覆盖getbuf的返回地址即可
getbuf申请的缓冲区为0x28 40 个字节
填充后再添加上地址即可
## touch2
- 要求我将cookie作为参数传入
目前在思考如何在正确位置传参
touch2 使用的是rdi,那么其必然是有使用内存引用的
那么,其放在哪个位置?
一番波折之后,这是不可能的
我们不可能通过缓冲区直接改写rdi中的数据
我们需要使用指令
所以
又是和ai交流后
得知一个关键
就是如何正确的使用我们写入的缓冲区
我们直接在缓冲区写入的数据会被当作一个地址
不过
这是在方法调用中
如果我们在方法调用后
再回到我们输入代码的这块缓冲区
编译器就会解读我们输入的机器码
所以我们将机器码写在开头
修改rdi的值
然后关键一点
我们该如何结束呢
这里使用了ret指令
我们利用rpi指针的特性
提前在第一次ret时将地址写在其后一位
之后rpi移动,我们再次ret就是读取我们写入的第二个地址
那么,就成功跳转离开
## touch3
该函数将rdi放入rbx中,cookie放入edi中
然后使用hexmatch函数,这应该是关键
要求函数调用后返回的eax不为0,即为成功
研究后,这个实验的重点不是让我们看汇编,而是让我们学会攻击手段
由于是让我们比较字符串是否相同
在计算机中,严格来说只有01,一切的数据类型都是对01的解释不同
我们可以使用ascii码的表示来输入cookie
通过缓冲区将cookie写入到内存中
然后将cookie的首地址移入rdi中
这样读取rdi时就会读取cookie
同时考虑内存上的位置
我们不能直接写在缓冲区中
因为后续的各个寄存器的压栈,会覆盖我们在缓冲区中的旧内容
所以我们写在高地址,缓冲区之外
保证不被破坏
思路至此,试试再说
不知道对栈的破坏会不会造成其它问题
还真有问题,不知道出于什么原因,虽然成功进入了touch3
但是被提前终止了
可能有抓人程序
### hexmatch
这个方法是比较两个字符串是否相同的
一个是系统内部的cookie
另一个是我们指定的
如何指定才是问题

